<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gzweb panel (standalone)</title>
  <style>
    /* Fill the viewport. */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #101014;
      color: #e5e5e5;
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
    }
    #gz-scene {
      width: 100%;
      height: 100%;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 6px;
      font-size: 13px;
      line-height: 1.4;
      z-index: 10;
      max-width: 360px;
    }
    #hud code {
      color: #b7ff8f;
    }
    #controls {
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }
    #controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    #controls input {
      flex: 1;
      padding: 4px 6px;
      background: #1c1c21;
      border: 1px solid #2e2e36;
      color: #e5e5e5;
      border-radius: 4px;
      font-size: 12px;
    }
    #controls button {
      padding: 6px 10px;
      background: #2b7cff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }
    #controls button:hover {
      background: #1f6ae0;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div>gzweb standalone panel</div>
    <div>ws: <code id="ws-url">unset</code></div>
    <div id="vm-info" style="display:none;">vm: <code id="vm-id"></code></div>
    <div id="status" style="display:none;">status: <code id="status-text"></code></div>
    <div id="controls">
      <label>VM Base: <input id="vm-base" placeholder="http://localhost:8080" /></label>
      <label>VM ID: <input id="vm-id-input" placeholder="vm-id" /></label>
      <label>Token: <input id="token-input" placeholder="optional" /></label>
      <label>WS (direct): <input id="ws-input" placeholder="ws://localhost:7681" /></label>
      <button id="connect-btn" type="button">Connect</button>
    </div>
  </div>
  <div id="gz-scene"></div>

  <script type="module">
    // Import gzweb via esm.sh with bundling so all deps are resolved inline.
    import { SceneManager } from 'https://esm.sh/gzweb@2.0.14?bundle';

    // Defaults (you can change these constants).
    // For DEFAULT_NODE_ID, use any id from /vms/status where status=="running".
    const DEFAULT_VM_BASE = 'http://localhost:8080';
    const DEFAULT_NODE_ID = '<id from /vms/status where status=="running">';
    const DEFAULT_TOKEN = ''; // if SKIP_JWT_VALIDATION=true & LOCAL_DEV=1
    const DEFAULT_WS = 'ws://localhost:7681'; // unused when VM Base + VM ID are set

    const vmBaseInput = document.getElementById('vm-base');
    const nodeIdInput = document.getElementById('vm-id-input');
    const tokenInput = document.getElementById('token-input');
    const wsInput = document.getElementById('ws-input');
    const connectBtn = document.getElementById('connect-btn');

    vmBaseInput.value = DEFAULT_VM_BASE;
    nodeIdInput.value = DEFAULT_NODE_ID;
    tokenInput.value = DEFAULT_TOKEN;
    wsInput.value = DEFAULT_WS;

    const hudStatus = document.getElementById('status');
    const hudStatusText = document.getElementById('status-text');
    const hudVmInfo = document.getElementById('vm-info');
    const hudVmId = document.getElementById('vm-id');
    const hudWsUrl = document.getElementById('ws-url');

    const NativeWebSocket = window.WebSocket;
    let sceneMgr;
    let resizeHandler;
    const pixelFormatEnumJson = {
      gz: {
        nested: {
          msgs: {
            nested: {
              PixelFormatType: {
                values: {
                  UNKNOWN_PIXEL_FORMAT: 0,
                  L_INT8: 1,
                  L_INT16: 2,
                  RGB_INT8: 3,
                  RGBA_INT8: 4,
                  BGRA_INT8: 5,
                  RGB_INT16: 6,
                  RGB_INT32: 7,
                  BGR_INT8: 8,
                  BGR_INT16: 9,
                  BGR_INT32: 10,
                  R_FLOAT16: 11,
                  RGB_FLOAT16: 12,
                  R_FLOAT32: 13,
                  RGB_FLOAT32: 14,
                  BAYER_RGGB8: 15,
                  BAYER_BGGR8: 16,
                  BAYER_GBRG8: 17,
                  BAYER_GRBG8: 18,
                  BAYER_RGGB16: 19,
                  BAYER_BGGR16: 20,
                  BAYER_GBRG16: 21,
                  BAYER_GRBG16: 22,
                  COMPRESSED_RGBA_INT8: 23,
                  RAW16: 24,
                  RAW8: 25,
                },
              },
            },
          },
        },
      },
    };

    function ensurePixelFormatEnum(root) {
      if (!root) return false;
      try {
        const existing = root.lookup('gz.msgs.PixelFormatType');
        if (existing) return false;
      } catch (err) {
        // root.lookup throws if the enum is missing; fall through to injection.
      }
      try {
        root.addJSON(pixelFormatEnumJson);
        if (typeof root.resolveAll === 'function') {
          root.resolveAll();
        }
        console.log('Injected fallback PixelFormatType enum into protobuf root');
        return true;
      } catch (err) {
        console.warn('Failed to inject PixelFormatType enum', err);
        return false;
      }
    }

    function patchTransportRoot(transport) {
      if (!transport || transport.__pixelFormatPatched) return;
      transport.__pixelFormatPatched = true;
      let currentRoot = transport.root;
      Object.defineProperty(transport, 'root', {
        get() { return currentRoot; },
        set(value) {
          currentRoot = value;
          ensurePixelFormatEnum(currentRoot);
        },
        configurable: true,
        enumerable: true,
      });
      ensurePixelFormatEnum(currentRoot);
    }

    /**
     * Optional shim: when connecting to a VM Manager websocket that requires a JSON
     * login handshake, we inject the login as the first message and queue all
     * subsequent sends until the login succeeds. Only enabled when vmBase/nodeId
     * query params are present.
     */
    const dataToString = async (data) => {
      if (typeof data === 'string') return data;
      if (data instanceof Blob) return await data.text();
      if (data instanceof ArrayBuffer) return new TextDecoder().decode(data);
      if (ArrayBuffer.isView(data)) return new TextDecoder().decode(data.buffer);
      return String(data ?? '');
    };

    function installVmManagerWebSocketShim({ token, nodeId }) {
      class VmManagerWebSocket {
        constructor(url, protocols) {
          this._ws = new NativeWebSocket(url, protocols);
          this._ready = false;
          this._queue = [];
          this.url = this._ws.url;
          this.protocol = this._ws.protocol;
          this.extensions = this._ws.extensions;
          this.binaryType = this._ws.binaryType;
          this._listeners = { open: [], message: [], close: [], error: [] };

          // Relay open immediately (gzweb waits for 'open' to start sending).
          this._ws.addEventListener('open', (ev) => {
            // Send the required login first.
            const loginMsg = {
              type: 'login',
              token: token ?? '',
              nodeId,
            };
            this._ws.send(JSON.stringify(loginMsg));
            this._emit('open', ev);
          });

          this._ws.addEventListener('message', (ev) => {
            if (!this._ready) {
              (async () => {
                try {
                  const msgStr = await dataToString(ev.data);
                  const msg = JSON.parse(msgStr);
                  if (msg.type === 'loginResponse') {
                    if (msg.success) {
                      this._ready = true;
                      document.getElementById('status-text').textContent = 'login ok';
                      document.getElementById('status').style.display = 'block';
                      this._flushQueue();
                    } else {
                      document.getElementById('status-text').textContent = msg.message || 'login failed';
                      document.getElementById('status').style.display = 'block';
                      this._ws.close();
                    }
                  } else {
                    // Unexpected pre-login message; ignore.
                  }
                } catch (err) {
                  console.warn('Failed to parse login response', err);
                }
              })();
              return;
            }

            // Ensure gzweb sees Blob data (it expects to FileReader.readAsText on event.data).
            let dataForClient = ev.data;
            if (!(dataForClient instanceof Blob)) {
              if (dataForClient instanceof ArrayBuffer || ArrayBuffer.isView(dataForClient)) {
                dataForClient = new Blob([dataForClient]);
              } else {
                dataForClient = new Blob([String(dataForClient)]);
              }
            }
            const wrappedEvent = new MessageEvent('message', { data: dataForClient });
            this._emit('message', wrappedEvent);
          });

          this._ws.addEventListener('error', (ev) => this._emit('error', ev));
          this._ws.addEventListener('close', (ev) => this._emit('close', ev));
        }

        get readyState() {
            return this._ws.readyState;
        }

        get bufferedAmount() {
          return this._ws.bufferedAmount;
        }

        set binaryType(type) {
          this._ws.binaryType = type;
        }

        get binaryType() {
          return this._ws.binaryType;
        }

        send(data) {
          if (!this._ready) {
            this._queue.push(data);
            return;
          }
          this._ws.send(data);
        }

        close(code, reason) {
          this._ws.close(code, reason);
        }

        addEventListener(type, listener, options) {
          if (this._listeners[type]) {
            this._listeners[type].push(listener);
          }
        }

        removeEventListener(type, listener, options) {
          if (!this._listeners[type]) return;
          this._listeners[type] = this._listeners[type].filter((l) => l !== listener);
        }

        _emit(type, event) {
          const handler = this[`on${type}`];
          if (typeof handler === 'function') {
            handler.call(this, event);
          }
          if (this._listeners[type]) {
            for (const l of this._listeners[type]) {
              try { l.call(this, event); } catch (err) { console.error(err); }
            }
          }
        }

        _flushQueue() {
          while (this._queue.length > 0) {
            const msg = this._queue.shift();
            this._ws.send(msg);
          }
        }
      }

      // Replace global WebSocket so gzweb uses the shim automatically.
      window.WebSocket = VmManagerWebSocket;
    }

    function resetWebSocketToNative() {
      window.WebSocket = NativeWebSocket;
    }

    function bindResize() {
      if (resizeHandler) {
        window.removeEventListener('resize', resizeHandler);
      }
      resizeHandler = () => sceneMgr?.resize();
      window.addEventListener('resize', resizeHandler);
    }

    function destroyScene() {
      if (sceneMgr) {
        sceneMgr.destroy();
        sceneMgr = undefined;
      }
      if (resizeHandler) {
        window.removeEventListener('resize', resizeHandler);
        resizeHandler = undefined;
      }
    }

    function connect() {
      destroyScene();
      hudStatus.style.display = 'none';
      hudVmInfo.style.display = 'none';
      const vmBase = vmBaseInput.value.trim();
      const nodeId = nodeIdInput.value.trim();
      const token = tokenInput.value.trim();
      const directWs = wsInput.value.trim();

      let websocketUrl = directWs || DEFAULT_WS;

      if (vmBase && nodeId) {
        installVmManagerWebSocketShim({ token, nodeId });
        websocketUrl = vmBase.replace(/^http/, 'ws') + '/ws';
        hudVmId.textContent = nodeId;
        hudVmInfo.style.display = 'block';
      } else {
        resetWebSocketToNative();
      }

      hudWsUrl.textContent = websocketUrl;

      sceneMgr = new SceneManager({
        elementId: 'gz-scene',
        websocketUrl,
        enableLights: true,
      });
      patchTransportRoot(sceneMgr.transport);

      bindResize();
    }

    connectBtn.addEventListener('click', () => {
      connect();
    });

    // Initial connect using defaults.
    connect();

    // Cleanup when the page unloads (useful when embedded in a VS Code webview later).
    window.addEventListener('beforeunload', () => {
      destroyScene();
    });
  </script>
</body>
</html>
